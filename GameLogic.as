package {	//imports	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.display.MovieClip;	import flash.utils.Timer;	import flash.utils.getTimer;		public class GameLogic{				private static var instance:GameLogic;						public static function getInstance():GameLogic {			if (instance == null) {				instance = new GameLogic();			}			return instance;		}						/*			TODO: GameState				NORMAL_GAMEPLAY				COLLECT_COMBO				BOSS_FIGHT					*/				private var validGameState:Array = ["State_WaitingForInput","State_Normal", "State_Combo", "State_Bossfight", "State_Victory"];				private var gamePaused:Boolean = false;				private var _State:String;		public function get State():String		{ 			return _State; 		}		public function set State(value:String):void		{			if (value == "State_Normal" && _State == "State_WaitingForInput")				resumeGame();			if (value !== _State && validGameState.indexOf(value) != -1)			{				_State = value;			}		}						private var updateTimer:Timer;		private var lastUpdatedTime:Number;					public var UPDATE_INTERVAL:Number = 40;		public var TOTAL_RUNNING_TIME:Number = 0;		public var RUNNING_TIME:Number = 0;				public var snake:Snake;		public var enemyManager;				public static var ValidType:Array = ["Speed", "Energy", "Absorb", "Regular"];						public function GameLogic(){		}				public function init(){			snake = Snake.getInstance();			enemyManager = EnemyManager.getInstance();			updateTimer = new Timer(UPDATE_INTERVAL,1);	//inifinite Loop			updateTimer.addEventListener(TimerEvent.TIMER_COMPLETE, update);			lastUpdatedTime = getTimer();						updateTimer.start();			pauseGame();			State = "State_WaitingForInput";		}						public function update(e:TimerEvent){			updateTime();			if (!gamePaused){				updateControl();				//updateGrids();				EnemyManager.getInstance().update();							snake.update();								if (snake.BodyPartList.length >= comboThreshold){					State = "State_Combo";				}else if (State == "State_Combo"){					State = "State_Normal";					resetStateCombo();				}				if (State == "State_Combo"){					updateComboState();				}			}						if (State == "State_Victory"){				GameVisual.getInstance().victory();			}			//always update visual			GameVisual.getInstance().update();		}						private function updateTime(){			// Check if turn is Finished			if (!gamePaused){				TOTAL_RUNNING_TIME += UPDATE_INTERVAL;				RUNNING_TIME += UPDATE_INTERVAL;			}			//New Timer			var currentTime:Number = getTimer();			//var newTimeInterval = UPDATE_INTERVAL - (currentTime - lastUpdatedTime - UPDATE_INTERVAL);			var newTimeInterval = UPDATE_INTERVAL;			lastUpdatedTime = currentTime;			if (newTimeInterval <= 0)				newTimeInterval = 5;			updateTimer = new Timer(newTimeInterval,1);	//inifinite Loop			updateTimer.start();			updateTimer.addEventListener(TimerEvent.TIMER_COMPLETE, update);								}							private var _Input:String = "";		public var LastInput:String = "";		public var LAST_INPUT_UPDATE:Number = 0;				public var blockInput:Boolean = false;				public function set Input(s:String){			if (blockInput)				return;						if (s == _Input)				return;							if (getReverse(s) == _Input && State != "State_WaitingForInput")				return;							if (State == "State_WaitingForInput")				State = "State_Normal";											switch (s){				case "UP":				case "DOWN":				case "LEFT":				case "RIGHT":					_Input = s;					LastInput = s;					break;			}		}				public static function getReverse(s:String):String		{			if (s == "UP")				return "DOWN";			if (s == "DOWN")				return "UP";			if (s == "LEFT")				return "RIGHT";			if (s == "RIGHT")				return "LEFT";			return null;		}				public function get Input():String{			return _Input;		}				public function resetInput(){			_Input = "";			LastInput = "";		}						private function updateControl(){						if (TOTAL_RUNNING_TIME - LAST_INPUT_UPDATE >= timeUntilNextMove()){				//move snake				moveSnake();				LAST_INPUT_UPDATE = TOTAL_RUNNING_TIME;				Input = "";			}		}				// Speed = ? Grid per second... for example 3g/s		//		timeNeeded for 1 grid= 1000 / 3				public function timeUntilNextMove():Number{			var speed = snake.Speed * (snake.hasSpecialState("Speed")? snake.getSpeedRatio() :1);			var timeNeeded:Number = 1000/speed;			return timeNeeded;		}				private function moveSnake(){			if (gamePaused)				return;						if (Input == "")				Input = LastInput;							var g:Grid = snake.head.grid;			var nextGrid:Grid = getNextGrid(g);						if (nextGrid == null){				hitBorder();				return;			}						if (snake.inBodyPartList(nextGrid)){				hitSelf(nextGrid);				return;			}			//Update GridList						var enemyHit:Boolean = false;						for each (var enemy in enemyManager.EnemyList){				if (nextGrid == enemy.grid){					enemyManager.removeEnemy(enemy);					enemyHit = true;					if (State == "State_Combo"){						if (enemy.Type == nextCombo){							comboCollected++;							nextCombo = "";						}						else{							comboCollected = 0							nextCombo = "";						}					}					break;				}			}						snake.moveToNextGrid(nextGrid, enemyHit);			//absorb starts after every movement			updateAbsorb();			GameVisual.getInstance().updateBackground(timeUntilNextMove()/800);		}				private function getNextGrid(g:Grid):Grid{			var nextI = g.idX;			var nextJ = g.idY;						switch (Input){				case "UP":					nextJ--;					break;				case "DOWN":					nextJ++;					break;								case "LEFT":					nextI--;					break;													case "RIGHT":					nextI++;					break;				default:					trace("Input Error !!!!");					return null;			}			if (GridSystem.outOfBorder(nextI, nextJ)){				return null;			}			var nextGrid = GridSystem.GridArray[nextI][nextJ];			return nextGrid;		}						private function updateAbsorb(){			if (!snake.hasSpecialState("Absorb"))				return;			var nextGrid = getNextGrid(snake.head.grid);			//hit border next			if (nextGrid == null)				return;			enemyManager.absorbEnemyToGrid(nextGrid);		}				private function hitSelf(nextGrid:Grid){			restart();		}				private function hitBorder(){			restart();		}						public static function getAdjucentGrids(sourceGrid:Grid, radius:int):Array		{			var oriI:int = sourceGrid.idX;			var oriJ:int = sourceGrid.idY;			var returnArray:Array = [];			for (var i:int = -radius; i <= radius; i++)			{				for (var j:int = -radius; j <= radius; j++)				{					var nextI:int = oriI + i;					var nextJ:int = oriJ + j;					if (!GridSystem.outOfBorder(nextI, nextJ)){						var grid = GridSystem.GridArray[nextI][nextJ];						returnArray.push(grid);					}									}			}			return returnArray;		}				///////////////////////////////////		///		State_ComboCollection		///////////////////////////////////				public var comboCollected:int = 0;		public var comboNeededToCollect:int = 6;		public var nextCombo = "";		public var comboThreshold:int = 12;				private function updateComboState(){			if (comboCollected >= comboNeededToCollect)				State = "State_Victory";			else if (nextCombo == "")				nextCombo = Enemy.getRandomType();					}				private function resetStateCombo(){					}						/////////////////////		///		MISC		/////////////////////				public function restart(){			trace("restart!");			//updateTimer.stop();			//ProjectSnake.getInstance().restart();			snake.restartAfterDeath();					}				public function pauseGame(){			gamePaused = true;			resetInput();					}				public function resumeGame(){			gamePaused = false;		}						public static function reset(){			instance = null;			}					}}