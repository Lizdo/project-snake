package {	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import fl.transitions.Tween;	import fl.transitions.easing.*;	import fl.transitions.TweenEvent;	import flash.display.Sprite;			public class EnemyManager extends Sprite{		private static var instance:EnemyManager;		public static function getInstance():EnemyManager {			if (instance == null)			{				instance = new EnemyManager  ;			}			return instance;		}		public function EnemyManager() {		}		private var gameLogic:GameLogic;		private var snake:Snake;				public function init(){			EnemyList = new Array();			gameLogic = GameLogic.getInstance();			snake = Snake.getInstance();		}		public var EnemyList:Array;		public var LAST_ENEMY_UPDATE = -3000;				public var ENEMY_SPAWN_INTERVAL = 1000;		public function update(){			if (patternSpawnInProgress)				updatePatternSpawn();			else if (gameLogic.TOTAL_RUNNING_TIME - LAST_ENEMY_UPDATE >= ENEMY_SPAWN_INTERVAL){				//spawnRandomEnemy();				//LAST_ENEMY_UPDATE = gameLogic.TOTAL_RUNNING_TIME;				getRandomSpawnPattern();			}						for each (var e in EnemyList)				e.update();		}				public function updateVisual(){			for each (var e in EnemyList){				e.updateVisual();			}		}				private function spawnRandomEnemy(){			var g:Grid = getRandomEmptyGrid();			//e.Type = "Absorb";			var type = Enemy.getRandomType();			spawnEnemy(g,type);		}				private function spawnEnemy(g:Grid, type:String, spawnTime:Number = 3, lifeSpan:Number = 10){			if (!g.isAvailable())				return;			var e:Enemy = new Enemy(g);			e.Type = type;			e.init(spawnTime, lifeSpan, spawnTime);			addChild(e);			EnemyList.push(e);		}				public function removeEnemy(e:Enemy){			if (EnemyList.indexOf(e) == -1)				return;			GameVisual.safelyRemove(e, this);			EnemyList.splice(EnemyList.indexOf(e),1);		}				//------------------------		//		Spawn Pattern		//------------------------						private var patternSpawnInProgress:Boolean = false;				private var patternSpawnInterval:Number = 1.5;	//can be overriden		private var patternSpawnInfoArray:Array = [];				// Spawn Pattern Array		//		grid, Type, spawnTime, lifeSpan				var lastRandomPattern:int = -1;				private function getRandomSpawnPattern(){			var rnd:int = Math.floor(Math.random() * 3);			while (rnd == lastRandomPattern)				rnd = Math.floor(Math.random() * 3);			lastRandomPattern = rnd;			switch (rnd)			{				case 0:					getPatternStar();					break;				case 1:					getPatternArc();					break;				case 2:					getPatternLine();					break;			}			patternSpawnInProgress = true;			lastPatternSpawned = gameLogic.TOTAL_RUNNING_TIME - patternSpawnInterval*1000;		}				private var lastPatternSpawned:int;				private function updatePatternSpawn(){			if (gameLogic.TOTAL_RUNNING_TIME - lastPatternSpawned >= patternSpawnInterval * 1000){				patternSpawn();				lastPatternSpawned = gameLogic.TOTAL_RUNNING_TIME;			}		}				private function patternSpawn(){			if (patternSpawnInfoArray.length == 0){				trace("Nothing to spawn");				patternSpawnInProgress = false;				LAST_ENEMY_UPDATE = lastPatternSpawned;				return;			}			var info:Array = patternSpawnInfoArray.shift();			spawnEnemy(info[0],info[1],info[2],info[3]);		}				// Pattern_Line				private function getPatternLine(){			var step:int = Math.ceil(Math.random() * 2);			var g:Grid = getValidPatternLineStartingGrid(step);			var type = Enemy.getRandomType();			var spawnTime = 3;			var lifeSpan = 8 + Math.random() * 4;			for (var i:int = 0; i < 5; i++){				var targetGrid:Grid = GridSystem.getGridByXY(g.idX, g.idY + i*step);				patternSpawnInfoArray.push([targetGrid, type, spawnTime, lifeSpan]);			}		}				private function getValidPatternLineStartingGrid(step:int):Grid{			var g:Grid = getRandomEmptyGrid();			for (var i:int = 1; i < 5; i++)			{				var grid:Grid = GridSystem.getGridByXY(g.idX, g.idY + i*step);				if (grid == null)					return getValidPatternLineStartingGrid(step);				else if (!grid.isAvailable())					return getValidPatternLineStartingGrid(step);				//non null && non occupied, go to next loop			}			return g;		}				// Pattern_Star				private var StarPatternArray:Array = [ [0,0],[2,0],[3,2],[2,4],[0,4],[-1,2]];						private function getPatternStar(){			var g:Grid = getValidPatternStarStartingGrid();			var type = Enemy.getRandomType();			var spawnTime = 3;			var lifeSpan = 8 + Math.random() * 4;						for each (var array in StarPatternArray){				var grid:Grid = GridSystem.getGridByXY(g.idX+array[0], g.idY + array[1]);				patternSpawnInfoArray.push([grid, type, spawnTime, lifeSpan]);								}								}				private function getValidPatternStarStartingGrid():Grid{			var g:Grid = getRandomEmptyGrid();			for each (var array in StarPatternArray){				if (!GridSystem.gridValidAndAvailableByXY(g.idX + array[0],g.idY + array[1]))					return getValidPatternStarStartingGrid();			}			return g;		}										// Pattern_Arc				private var ArcPatternArray:Array = [ [0,0],[3,1],[6,3],[8,5],[10,8]];						private function getPatternArc(){			var g:Grid = getValidPatternArcStartingGrid();			var spawnTime = 3;			var lifeSpan = 8 + Math.random() * 4;						for each (var array in ArcPatternArray){				var grid:Grid = GridSystem.getGridByXY(g.idX+array[0], g.idY + array[1]);				var type = Enemy.getRandomType();				patternSpawnInfoArray.push([grid, type, spawnTime, lifeSpan]);								}								}				private function getValidPatternArcStartingGrid():Grid{			var g:Grid = getRandomEmptyGrid();			for each (var array in ArcPatternArray){				if (!GridSystem.gridValidAndAvailableByXY(g.idX + array[0],g.idY + array[1]))					return getValidPatternArcStartingGrid();			}			return g;		}										//------------------------		//		Absorb		//------------------------				private function getRandomEmptyGrid():Grid{			var rndX = Math.floor(Math.random() * GridSystem.BATTLEFIELD_X);			var rndY = Math.floor(Math.random() * GridSystem.BATTLEFIELD_Y);			if (GridSystem.outOfBorder(rndX, rndY))				return getRandomEmptyGrid();			var g:Grid = GridSystem.GridArray[rndX][rndY];			if (snake.inBodyPartList(g))				return getRandomEmptyGrid();			for each (var enemy in EnemyList){				if (GridSystem.distance(g, enemy.grid) <= 2)					return getRandomEmptyGrid();			}			return g;		}		var TweenArray:Array = [];				public function absorbEnemyToGrid(g:Grid){			var enemy:Enemy = getEnemyToAbsorb(g);			if (enemy == null)				return;			//add latent function for moving the enemy TBD			var tweenTime:Number = gameLogic.timeUntilNextMove() * 0.4/1000;			trace(tweenTime);			var absorbTweenX:Tween = new Tween(enemy, "x", Regular.easeIn, enemy.x, g.x, tweenTime, true);			var absorbTweenY:Tween = new Tween(enemy, "y", Regular.easeIn, enemy.y, g.y, tweenTime, true);			enemy.movingInProgress = true;			absorbTweenX.addEventListener(TweenEvent.MOTION_FINISH, absorbTweenCompleted);			absorbTweenX.start();			absorbTweenY.start();			TweenArray.push(absorbTweenX);			TweenArray.push(absorbTweenY);			TweenArray.push(enemy);			TweenArray.push(g);		}				private function absorbTweenCompleted(e:TweenEvent){			TweenArray[2].grid = TweenArray[3];			TweenArray[2].movingInProgress = false;			TweenArray = [];		}				public function getEnemyToAbsorb(g:Grid):Enemy{			var adjucentGrids = GameLogic.getAdjucentGrids(g, Math.ceil(snake.absorbRadius))			for each (var grid in adjucentGrids){				if (grid.enemy != null)					return grid.enemy;			}			return null;		}						//------------------------		//		Misc		//------------------------								public static function reset(){			instance = null;		}	}}